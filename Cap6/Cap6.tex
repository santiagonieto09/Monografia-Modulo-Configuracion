\mychapter{Capítulo 6. Implementación}

En este capítulo se presentan los aspectos técnicos y las decisiones de diseño adoptadas durante la construcción del sistema, organizando la implementación en dos grandes áreas: el desarrollo del backend (lado del servidor) y la interfaz de usuario (frontend). La aplicación está desplegada en un entorno de pruebas, accesible mediante la siguiente \href{http://contables.unicauca.edu.co/dev}{\underline{\textcolor{blue}{URL}}}.

Por motivos de seguridad de la División de TIC, dentro de la institución es necesario conectarse a través de una VPN para acceder al entorno; fuera de la red universitaria, el acceso es libre. El código fuente de los microservicios que conforman el módulo de configuración está disponible en los siguientes repositorios de GitHub:

\begin{itemize}
    \item \textbf{account-catalogue:} \href{https://github.com/Equipo-dinamita-escuadron-lobo/account-catalogue/tree/develop}{\underline{\textcolor{blue}{Enlace}}} \\ 
    Contiene los módulos de catálogo de cuentas, métodos de pago, impuestos, bancos y cuentas bancarias.
    \item \textbf{thirds-management:} \href{https://github.com/Equipo-dinamita-escuadron-lobo/thirds-management/tree/develop}{\underline{\textcolor{blue}{Enlace}}} \\ 
    Incluye la gestión de terceros, tipos de identificación y tipos de terceros.
    \item \textbf{products-management:} \href{https://github.com/Equipo-dinamita-escuadron-lobo/products-management/tree/develop}{\underline{\textcolor{blue}{Enlace}}} \\ 
    Incluye la gestión de productos, categorías, unidades de medida y tipos de producto.
    \item \textbf{ms-configuration:} \href{https://github.com/Equipo-dinamita-escuadron-lobo/ms-configuration/tree/develop}{\underline{\textcolor{blue}{Enlace}}} \\ 
    Abarca los módulos de calendario contable, clases y tipos de documentos, centros de costo y centro de ayuda.
\end{itemize}

\section{Backend}
\subsection{Patrones de diseño}

Los patrones de diseño representan estrategias recurrentes para abordar problemas comunes en el desarrollo de software, que funcionan como guías conceptuales que pueden adaptarse y personalizarse según las necesidades específicas de cada proyecto. A diferencia de una función o biblioteca lista para usar, un patrón de diseño no es un fragmento de código concreto, sino una solución abstracta que orienta la estructura y organización del programa. Su implementación requiere interpretar el concepto y ajustarlo a las particularidades del sistema en desarrollo \cite{patterndesign}.

En las siguientes secciones se contextualizan los patrones de diseño implementados. Para cada patrón se presenta una breve introducción, se explican las motivaciones que llevaron a su uso y se incluyen representaciones gráficas que ilustran su aplicación dentro del módulo de configuración.


\subsection{Patrón strategy}

Es una solución de diseño orientada al comportamiento que facilita la definición de múltiples algoritmos relacionados, encapsulando cada uno en una clase distinta y permitiendo que sus instancias se puedan intercambiar dinámicamente según las necesidades del sistema. El patrón Strategy se compone de tres elementos fundamentales: el contexto, que mantiene una referencia a una estrategia y delega en ella la ejecución de la tarea, la interfaz Strategy, que establece un contrato común para todas las estrategias concretas y las estrategias concretas, que implementan las distintas variantes del algoritmo. Esta organización permite separar la lógica de negocio de los detalles específicos de cada algoritmo, lo que facilita la realización de pruebas y la evolución del sistema \cite{refactoringStrategy}.


 \subsubsection{Diagrama de clases}

La \autoref{fig:strategy} ilustra la implementación del patrón Strategy en el módulo de terceros en las funciones de importación para validar archivos de diferentes tipos (como PDF y Excel) de manera flexible y extensible. Esto permite encapsular algoritmos de validación específicos en clases concretas (\texttt{PdfFileValidator} y \texttt{ExcelFileValidator}), que implementan la interfaz común \texttt{FileValidator}. Los servicios como \texttt{PdfRUTService} y \texttt{ExcelParsingService} dependen de la interfaz, no de implementaciones concretas, lo que facilita intercambiar validadores dinámicamente sin modificar el código cliente. Esta separación mejora la mantenibilidad, permite agregar nuevos tipos de validación (por ejemplo, para CSV) siguiendo el principio Abierto/Cerrado y evita duplicación de lógica de validación en múltiples servicios, simplificando la estructura del backend.

\begin{figure}[h!]
    \centering%
    \includegraphics[width=1.0\textwidth, height=1.0\textheight, keepaspectratio]{Cap6/Figuras/strategy.png}    
    \caption{Diagrama de clases del patrón Strategy}
    \label{fig:strategy}
\end{figure}

\newpage
\subsubsection{Motivación e implementación}

La implementación del patrón Strategy en este proyecto surge de la necesidad de manejar diferentes tipos de archivos al importar datos en el módulo de terceros. Este módulo debía ser capaz de procesar tanto archivos PDF del RUT de la DIAN como archivos Excel para la importación masiva de terceros. El patrón Strategy permitió encapsular las distintas estrategias de validación y procesamiento de archivos en clases separadas, facilitando la adición de nuevos formatos en el futuro sin afectar la lógica existente. Al depender de una interfaz común, los servicios pueden intercambiar fácilmente las estrategias según el tipo de archivo que se esté manejando. 

La clase \texttt{FileValidator} en la \autoref{fig:FileValidator} define el contrato para validar archivos subidos, con métodos como \texttt{validate(MultipartFile file)} para verificar integridad, \texttt{getSupportedMimeTypes()} para tipos MIME admitidos y \texttt{getSupportedExtensions()} para extensiones (.pdf, .xlsx), esto asegura una validación uniforme sin importar el tipo de archivo.

\begin{figure}[h!]
    \centering%
    \includegraphics[width=1.0\textwidth, height=1.0\textheight, keepaspectratio]{Cap6/Figuras/FileValidator.png}    
    \caption{Clase FileValidator interfaz}
    \label{fig:FileValidator}
\end{figure}


\newpage
La clase \texttt{PdfFileValidator} (estrategia concreta) en la \autoref{fig:PDFValidator} valida archivos PDF del RUT, verificando que cumplan con propiedades como tamaño máximo y extensiones permitidas definidas en \texttt{FileUploadProperties}. Se inyecta en servicios específicos para PDFs.

\begin{figure}[h!]
    \centering%
    \includegraphics[width=1.0\textwidth, height=1.0\textheight, keepaspectratio]{Cap6/Figuras/PDFValidator.png}    
    \caption{Clase PdfFileValidator estrategia concreta}
    \label{fig:PDFValidator}
\end{figure}

\newpage
La clase \texttt{ExcelFileValidator} (estrategia concreta) en la Figura \ref{fig:Excelvalidator} valida archivos Excel para importación masiva de terceros, aplicando las mismas reglas de configuración. Ambas clases dependen de \texttt{FileUploadProperties} para configuraciones centralizadas, evitando hardcoding.

\begin{figure}[h!]
    \centering%
    \includegraphics[width=1.0\textwidth, height=1.0\textheight, keepaspectratio]{Cap6/Figuras/Excelvalidator.png}    
    \caption{Clase ExcelFileValidator estrategia concreta}
    \label{fig:Excelvalidator}
\end{figure}



\subsection{Patrón observer}

Es un patrón de diseño de comportamiento en el que un objeto, llamado sujeto, mantiene una lista de sus dependientes, llamados observadores, y les notifica automáticamente cualquier cambio de estado. Este patrón es útil cuando los cambios en el estado de un objeto pueden requerir cambios en otros objetos, y el grupo de objetos puede ser desconocido de antemano o cambiar dinámicamente. Además, el patrón Observer ayuda a desacoplar los componentes del sistema, lo que facilita su mantenimiento y escalabilidad \cite{Observer}. 

 \subsubsection{Diagrama de clases}
La implementación del patrón Observer en el módulo de configuración se centra en la actualización asíncrona de contadores de uso de recursos, como centros de costo, en respuesta a eventos generados por otros microservicios, como \texttt{ms-debt-payments}. El microservicio \texttt{ms-debt-payments} actúa como publicador que envía notificaciones cuando se utiliza un recurso. Estas notificaciones son consumidas por el microservicio \texttt{ms-configuration} que contiene el módulo de centros de costo, que actúa como suscriptor, actualizando el contador de uso en la base de datos.

El sistema implementa una arquitectura orientada a eventos para desacoplar el microservicio \texttt{ms-debt-payments} del microservicio \texttt{ms-configuration}. El diagrama general de la \autoref{fig:observer} ilustra cómo se aplica el patrón Observer para la actualización asíncrona de contadores.

\begin{figure}[h!]
    \centering%
    \includegraphics[width=1.0\textwidth, height=1.0\textheight, keepaspectratio]{Cap6/Figuras/observer.png}    
    \caption{Diagrama de clases del patrón Observer}
    \label{fig:observer}
\end{figure}

\subsubsection{Motivación e implementación}

 La motivación para implementar el patrón Observer en este contexto radica en la necesidad de mantener actualizados los contadores de uso de recursos (como centros de costo) en el módulo de configuración con el fin de validar las acciones de editar y eliminar si estos parametros han tenido movimientos contables lo cual evita inconsistencias en la generacion de reportes o procesos contables.

El flujo de eventos para la actualización del contador de uso de centros de costo sigue estos pasos:


\begin{itemize}
    \item El microservicio \texttt{ms-debt-payments} detecta el uso de un recurso (centro de costo) y crea una notificación interna (\texttt{CostCenterUsedNotification}).
    \item La notificación es enviada al exchange \texttt{costcenter.used.exchange} mediante el publicador (\texttt{ResourceUsagePublisher}).
    \item La cola \texttt{costcenter.used.queue} recibe el mensaje.
    \item El microservicio \texttt{ms-configuration}, que contiene el módulo de centros de costo, consume el evento a través del listener (\texttt{CostCenterUsageListener}).
    \item El listener procesa el evento y actualiza la base de datos mediante la interfaz \texttt{IUsageCostCenter}, incrementando el contador de uso del centro de costo correspondiente.
\end{itemize}



 La Figura \ref{fig:publisher} muestra la clase \verb|ResourceUsagePublisher|, ubicada en la capa de infraestructura de \verb|ms-debt-payments|. Su función principal es enrutar las notificaciones al exchange correcto. El método \verb|dispatch(ResourceUsageNotification notification)| actúa como un switcher. Utiliza \verb|instanceof| para determinar el tipo de notificación y delegar al manejador específico.


Este diseño permite manejar distintos tipos de recursos enviando eventos a exchanges específicos:

\begin{itemize}
    \item \verb|THIRD_USED_EXCHANGE| para \verb|ThirdPartyUsedNotification|.
    \item \verb|COSTCENTER_USED_EXCHANGE| para \verb|CostCenterUsedNotification|.
    \item \verb|PAYMENTMETHOD_USED_EXCHANGE| para \verb|PaymentMethodUsedNotification|.
\end{itemize}


\textbf{Nota adicional:} El microservicio \verb|debt payments| no solo gestiona centros de costo. También envía eventos a terceros y métodos de pago utilizando el mismo tipo de evento de uso (\verb|EventUsageType.USED|). Estos eventos incrementan sus respectivos contadores siguiendo una lógica análoga a la descrita aquí.


\begin{figure}[h!]
    \centering%
    \includegraphics[width=1.0\textwidth, height=1.0\textheight, keepaspectratio]{Cap6/Figuras/publisher.png}    
    \caption{Publicador de notificaciones de uso de recursos}
    \label{fig:publisher}
\end{figure}

\newpage
Para el manejo específico de la notificación, la \autoref{fig:handler} detalla el método \verb|"handle"| encargado de transformar la notificación interna en un evento de integración. En doonde se crea un objeto \verb|CostCenterUsedDto| con el \verb|costCenterId|, \verb|enterpriseId| y una \verb|quantityUsed|, envuelve el DTO en un \verb|EventDto| con el tipo \verb|"USED"| y utiliza \verb|convertAndSend| para publicar en \verb|COSTCENTER_USED_EXCHANGE|.

\begin{figure}[h!]
    \centering%
    \includegraphics[width=1.0\textwidth, height=1.0\textheight, keepaspectratio]{Cap6/Figuras/handler.png}    
    \caption{Manejo de la notificación}
    \label{fig:handler}
\end{figure}


Para el consumo del evento la Figura \ref{fig:listener} muestra la clase \verb|CostCenterUsageListener| en el microservicio \verb|ms-configuration|. La recepción en el método (\verb|handleCostCenterEvent|) se realiza de la siguiente manera:

\begin{itemize}
\item Anotado con \verb|@RabbitListener| escuchando en \verb|COST_CENTER_USED_QUEUE|.
\item Recibe el \verb|EventDto|, \verb|Message|, \verb|Channel| y el \verb|deliveryTag|.
\item Delega la gestión de ACK/NACK al método padre \verb|handleMessage|.
\end{itemize}

El procesamiento del evento en \verb|processEvent| sigue estos pasos:

\begin{itemize}
\item Switch de tipo: Evalúa \verb|event.getType()|, actualmente soporta \verb|EventUsageType.USED|.
\item Validación: Llama a \verb|isValidEvent()| para asegurar que \verb|costCenterId| no sea nulo y que \verb|quantityUsed| sea mayor que cero.
\item Acción: Si es válido, invoca a \verb|incrementUsageCount(data.getCostCenterId())|.
\item Manejo de Errores: Si el evento no es válido o el tipo no es soportado, lanza excepciones como \verb|IllegalArgumentException|.
\end{itemize}

\begin{figure}[h!]
    \centering%
    \includegraphics[width=1.0\textwidth, height=1.0\textheight, keepaspectratio]{Cap6/Figuras/listener.png}    
    \caption{Listener para el consumo de eventos de uso de centros de costo}
    \label{fig:listener}
\end{figure}


\section{Frontend}

\subsection{Estilos visuales}

Se definieron estilos visuales específicos siguiendo las guias de diseño para componentes de retroalimentación e interacción proporcionadas por la división TICS de la Universidad del Cauca. La Figura \ref{fig:fig4} y Figura \ref{fig:fig5} muestran los estilos estandarizados para las alertas del sistema y los botones globales, asegurando que el usuario reciba feedback visual consistente ante sus acciones.

\begin{figure}[h!]
    \centering%
    \includegraphics[width=0.8\textwidth, height=0.4\textheight, keepaspectratio]{Cap6/Figuras/notificacion.png}    
    \caption{Estilos de alertas del sistema}
    \label{fig:fig4}
\end{figure}

\begin{figure}[h!]
    \centering%
    \includegraphics[width=0.8\textwidth, height=0.4\textheight, keepaspectratio]{Cap6/Figuras/botones.png}    
    \caption{Estilos de botones globales}
    \label{fig:fig5}
\end{figure}


\subsection{Implementación técnica con Tailwind CSS}

Con el propósito de simplificar la implementación de estos estilos para el grupo de desarrolladores y preservar la consistencia en el código, se elaboraron definiciones globales en el archivo principal de estilos (styles.css). Utilizando la estructura del framework Tailwind CSS, se ajustaron variables CSS personalizadas que vinculan los colores institucionales con clases de utilidad.

Tal como se muestra en la Figura \ref{fig:variablescss}, se establecieron las variables CSS para la gama de colores, la ilustración muestra un ejemplo representativo de los matices definidos, con configuraciones extra para abarcar todos los estados y variantes necesarios en la interfaz. Esta aproximación facilita la expansión de la configuración de Tailwind para emplear clases semánticas tales como bg-primary o text-neutral-50, evitando la dispersión de códigos hexadecimales en el código.

\begin{figure}[h!]
    \centering%
    \includegraphics[width=0.8\textwidth, height=0.8\textheight, keepaspectratio]{Cap6/Figuras/variablescss.png}    
    \caption{Definición de variables CSS personalizadas para Tailwind CSS}
    \label{fig:variablescss}
\end{figure}


Complementariamente, la Figura \ref{fig:tipografias} detalla la configuración técnica de las tipografías.
 Se establecieron las reglas \verb|@font-face| para las familias Open Sans y Titillium Web,
 asegurando su disponibilidad y correcta renderización en toda la aplicación.

\begin{figure}[h!]
    \centering%
    \includegraphics[width=1.0\textwidth, height=1.0\textheight, keepaspectratio]{Cap6/Figuras/tipografia.png}    
    \caption{Configuración de tipografías globales}
    \label{fig:tipografias}
\end{figure}

\newpage
Esta metodología de desarrollo no únicamente garantiza la adherencia a las directrices de diseño, sino que además mejora la eficiencia en el proceso de trabajo de los programadores. La Figura \ref{fig:utilitarias} ilustra la manera en que se integran estos estilos en el código HTML, fusionando la sintaxis utilitaria de Tailwind con las configuraciones específicas del sistema de diseño.

\begin{figure}[h!]
    \centering%
    \includegraphics[width=1.0\textwidth, height=1.0\textheight, keepaspectratio]{Cap6/Figuras/utilitarias.png}    
    \caption{Aplicación de estilos globales en el código HTML}
    \label{fig:utilitarias}
\end{figure}

El resultado de esta abstracción es un código fuente más ordenado y fácil de mantener, en el cual la complejidad visual queda contenida dentro de las configuraciones del framework, asegurando que cualquier modificación posterior en la identidad visual se pueda difundir de manera efectiva por todo el sistema alterando solo las variables globales.